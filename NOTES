Design notes...

1. Internal identification of users and groups
----------------------------------------------

Users and groups are both identified by 2- or 3-element tuples of the
form:

  (name, persistent identifier [, DN])

For example:

  ("dryad", "ark:/13030/foo", "uid=dryad,ou=People,ou=uc3,dc=cdlib,dc=org")

The last tuple element is present only if LDAP is enabled.

In the UI, if the user is not logged in, the user and group are both
set to ("anonymous", "anonymous") for the purposes of identifier
ownership and access control.

2. Session cookies
------------------

Session cookies store the following key/value pairs:

  auth
    A userauth.AuthenticatedUser object which has 'user' and 'group'
    attributes, each of which is a tuple as described above.
    Presence of this key indicates that the user is authenticated.

  prefixes
    A list of the prefixes to which the user has access.  Each element
    of the list is a dictionary with keys 'prefix' and 'namespace',
    e.g., { "prefix": "ark:/13030/c7", "namespace": "EZID ARK" }.  Set
    and used only by the UI for rendering purposes, not access
    control.  Present iff the user is authenticated.

  redirect_to
    The full URL path to which the user should be redirected following
    a successful login.  UI only.  May or may not be present; not
    cleared.

3. Caching
----------

Caching is employed in several places:

  ezid.conf settings
    Cached in various modules.  Loaded at module load time.  Invoking
    the "Reload EZID" admin function causes all settings to be
    reloaded (except logging settings).

  userauth._ldapCache authentication cache
    A dictionary that maps local usernames to AuthenticatedUser
    objects.  Loaded on demand as usernames are encountered.  Emptied
    when EZID is reloaded.

  policy._groups prefix cache
    A dictionary that maps groups (identified by tuples; see above) to
    lists of prefixes.  Loaded on demand as groups are encountered.
    Emptied when EZID is reloaded.  Also, individual entries are
    removed when shoulder lists are modified through the admin
    interface.

  policy._coOwners cache
    A dictionary that maps users (identified by simple names) to
    co-owner lists (in which users are also identified by simple
    names).  Loaded on demand as users are encountered.  Emptied when
    EZID is reloaded.  Also, individual entries are removed when
    co-owner lists are modified through the account and admin
    interfaces.

  search._coOwnershipMap cache
    A dictionary that maps users to lists of other users that have
    named them as account-level co-owners.  I.e., if users A and B
    both name user C as an account-level co-owner, then this map will
    contain an entry C -> [A, B].  Users are identified by ARK
    identifiers.  Computed once on demand.  Emptied when EZID is
    reloaded and when any account-level co-ownership list is modified.

  session cookies
    See above.  A session cookie is invalidated if/when a user logs
    out, but otherwise there's currently no way to invalidate a
    session cookie.  (SESSION_EXPIRE_AT_BROWSER_CLOSE is set to true,
    but that only directs browsers to drop cookies, it doesn't
    actually invalidate them.)

  idmap.py: _idMap, _groupMap, _userMap
    These dictionaries cache correspondences between agent identifiers
    and user and group local names.  Loaded on demand.  Emptied when
    EZID is reloaded.

  LDAP information
    Cached in agent identifiers for the purposes of storage redundancy
    and locality only.  Written only, never read.

These can be considered caches as well:

  store database
    Serves as a local backup for the primary "bind" noid database;
    also supports identifier harvesting.  Stores all identifiers and
    all metadata.

  search database
    Supports searching and browsing over identifier metadata.  Stores
    some identifiers (most are included, but, e.g., anonymously-owned
    identifiers are excluded) and just that metadata needed for
    searching.

4. Identifier metadata
----------------------

See ezid.py.

5. Agent identifiers
--------------------

"Agents" (users and groups) are internally referred to and stored as
ARK identifiers (e.g., "ark:/99166/foo"), but are externally referred
to by local names (e.g., "dryad").  Identifiers that identify agents
are termed "agent identifiers;" see ezid.py and idmap.py for more
information.  Because potentially sensitive LDAP information is cached
in agent identifiers (see above), not only are agent identifiers not
revealed to clients, they are owned by the EZID administrator and can
only be viewed by the EZID administrator.

The search database contains agent identifiers; see
.../etc/search-schema.sql for a potential privacy/security hole.

6. Case sensitivity of LDAP UIDs
--------------------------------

LDAP UIDs are case-insensitive.  Whenever EZID stores a UID (e.g., in
session cookies and in co-owner lists), it always uses the UID as
retrieved from LDAP.  In other words, when LDAP is enabled, EZID's
behavior regarding UIDs is case-insensitive and case-preserving.

7. Use of DataCite's active flag
--------------------------------

DataCite's 'active' flag (a DataCite-specific attribute of a DOI)
works as follows.  It is true by default, and set to false by
performing an HTTP DELETE on the identifier.  Note, though, that a
DELETE may be performed only if the identifier has metadata.
Performing a DELETE on an already deactivated identifier has no
effect.  An identifier is (and can only be) reactivated by posting
metadata to it.

A deactivated identifier continues to exist in DataCite, but it is in
many ways deleted: an attempt to view the identifier returns 410 Gone,
and the identifier is removed from every DataCite service, including
the CrossRef/DataCite content resolver.  It is not entirely deleted,
however, as the identifier continues to exist in the Handle System and
therefore continues to resolve.

Note that the above API behavior has no effect on setting a DOI's
target URL: the target URL may be set whether the identifier is active
or not, and whether it has metadata or not.  Starting 2013-01-01
DataCite will disallow a new registration if the identifier has no
metadata.  Our understanding is that nothing else about the DataCite
API will change, in particular, that the target URL will continue to
be settable if the identifier is not active.  It is unclear at the
time of this writing if the target URL for a legacy identifier lacking
metadata may be set without first uploading metadata.

With this background, EZID's manipulation of the active flag can be
summarized as follows:

  event                           actions
  ------------------------------  -------------------------
  _status: public -> unavailable  url=tombstone; DEACTIVATE
  _status: unavailable -> public  restore url; ACTIVATE
  delete                          url=invalid; DEACTIVATE
  _export: yes -> no              DEACTIVATE
  _export: no -> yes              ACTIVATE

In the above, _status takes precedence over _export.

There are two differences between an unavailable identifier and a
public-but-not-exported identifier.  First, an unavailable
identifier's target URL is overriden with a tombstone URL.  Second, a
public-but-not-exported identifier's metadata is still uploaded to
DataCite.

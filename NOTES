Design notes...

1. Internal identification of users and groups
----------------------------------------------

Users and groups are both identified by 2- or 3-element tuples of the
form:

  (name, persistent identifier [, DN])

For example:

  ("dryad", "ark:/13030/foo", "uid=dryad,ou=People,ou=uc3,dc=cdlib,dc=org")

The last tuple element is present only if LDAP is enabled.

In the UI, if the user is not logged in, the user and group are both
set to ("anonymous", "anonymous") for the purposes of identifier
ownership and access control.

2. Session cookies
------------------

Session cookies store the following key/value pairs:

  auth
    A userauth.AuthenticatedUser object which has 'user' and 'group'
    attributes, each of which is a tuple as described above.
    Existence of this key indicates that the user is authenticated.

  prefixes
    A list of the prefixes to which the user has access.  Each element
    of the list is a dictionary with keys 'prefix' and 'namespace',
    e.g., { "prefix": "ark:/13030/c7", "namespace": "EZID ARK" }.  Set
    and used only by the UI for rendering purposes, not access
    control.

  history
    A list of previously-visited identifiers.  Each element of the
    list is a dictionary with keys 'id' (the identifier), 'url' (the
    relative URL of the identifier's management page), and
    'abbreviated' (the possibly abbreviated display version of the
    identifier).  UI only.

3. Caching
----------

Caching is employed in several places:

  ezid.conf settings
    Cached in various modules.  Loaded at module load time.  Invoking
    the "Reload EZID" admin function causes all settings to be
    reloaded (except logging settings).

  policy._groups prefix cache
    A dictionary that maps groups (identified by tuples; see above) to
    lists of prefixes.  Loaded on demand as groups are encountered.
    Emptied when EZID is reloaded.  Also, individual entries are
    removed when shoulder lists are modified through the admin
    interface.

  session cookies
    See above.  A session cookie is invalidated if/when a user logs
    out, but otherwise there's currently no way to invalidate a
    session cookie.

  idmap.py: _idMap, _groupMap, _userMap
    These dictionaries cache correspondences between agent identifiers
    and user and group local names.  Loaded on demand.  Emptied when
    EZID is reloaded.

  LDAP information
    Cached in agent identifiers for the purposes of storage redundancy
    and locality only.  Written only, never read.
    (Known bug: LDAP does not store empty attribute values; instead,
    it deletes attributes.  A consequence of this behavior is that if
    an LDAP attribute, say, ezidCoOwners, has a non-empty value at
    some point and then is cleared, and therefore deleted by LDAP,
    then EZID will lose awareness of the very existence of the
    attribute and will therefore leave the old attribute value cached.
    The fix for this is to keep track of LDAP attribute deletions.)

4. Identifier metadata
----------------------

See ezid.py.

5. Agent identifiers
--------------------

"Agents" (users and groups) are internally referred to and stored as
ARK identifiers (e.g., "ark:/99166/foo"), but are externally referred
to by local names (e.g., "dryad").  Identifiers that identify agents
are termed "agent identifiers;" see ezid.py and idmap.py for more
information.  Because potentially sensitive LDAP information is cached
in agent identifiers (see above), not only are agent identifiers not
revealed to clients, they are owned by the EZID administrator and can
only be viewed by the EZID administrator.  To avoid coding
complications (ezid.getMetadata is used both to service client
requests and by EZID itself) this special access control is
implemented in the API and UI, not in ezid.py.

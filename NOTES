Design notes...

1. Internal identification of users and groups
----------------------------------------------

Users and groups are both identified by 2- or 3-element tuples of the
form:

  (name, persistent identifier [, DN])

For example:

  ("dryad", "ark:/13030/foo", "uid=dryad,ou=People,ou=uc3,dc=cdlib,dc=org")

The last tuple element is present only if LDAP is enabled.

In the UI, if the user is not logged in, the user and group are both
set to ("anonymous", "anonymous") for the purposes of identifier
ownership and access control.

2. Session cookies
------------------

Session cookies store the following key/value pairs:

  auth
    A userauth.AuthenticatedUser object which has 'user' and 'group'
    attributes, each of which is a tuple as described above.
    Presence of this key indicates that the user is authenticated.

  prefixes
    A list of the prefixes to which the user has access.  Each element
    of the list is a dictionary with keys 'prefix' and 'namespace',
    e.g., { "prefix": "ark:/13030/c7", "namespace": "EZID ARK" }.  Set
    and used only by the UI for rendering purposes, not access
    control.  Present iff the user is authenticated.

  redirect_to
    The full URL path to which the user should be redirected following
    a successful login.  UI only.  May or may not be present; not
    cleared.

3. Caching
----------

Caching is employed in several places:

  ezid.conf settings
    Cached in various modules.  Loaded at module load time.  Invoking
    the "Reload EZID" admin function causes all settings to be
    reloaded (except logging settings).

  policy._groups prefix cache
    A dictionary that maps groups (identified by tuples; see above) to
    lists of prefixes.  Loaded on demand as groups are encountered.
    Emptied when EZID is reloaded.  Also, individual entries are
    removed when shoulder lists are modified through the admin
    interface.

  policy._coOwners cache
    A dictionary that maps users (identified by simple names) to
    co-owner lists (in which users are also identified by simple
    names).  Loaded on demand as users are encountered.  Emptied when
    EZID is reloaded.  Also, individual entries are removed when
    co-owner lists are modified through the account and admin
    interfaces.

  search._coOwnershipMap cache
    A dictionary that maps users to lists of other users that have
    named them as account-level co-owners.  I.e., if users A and B
    both name user C as an account-level co-owner, then this map will
    contain an entry C -> [A, B].  Users are identified by ARK
    identifiers.  Computed once on demand.  Emptied when EZID is
    reloaded and when any account-level co-ownership list is modified.

  session cookies
    See above.  A session cookie is invalidated if/when a user logs
    out, but otherwise there's currently no way to invalidate a
    session cookie.  (SESSION_EXPIRE_AT_BROWSER_CLOSE is set to true,
    but that only directs browsers to drop cookies, it doesn't
    actually invalidate them.)

  idmap.py: _idMap, _groupMap, _userMap
    These dictionaries cache correspondences between agent identifiers
    and user and group local names.  Loaded on demand.  Emptied when
    EZID is reloaded.

  LDAP information
    Cached in agent identifiers for the purposes of storage redundancy
    and locality only.  Written only, never read.

4. Identifier metadata
----------------------

See ezid.py.

5. Agent identifiers
--------------------

"Agents" (users and groups) are internally referred to and stored as
ARK identifiers (e.g., "ark:/99166/foo"), but are externally referred
to by local names (e.g., "dryad").  Identifiers that identify agents
are termed "agent identifiers;" see ezid.py and idmap.py for more
information.  Because potentially sensitive LDAP information is cached
in agent identifiers (see above), not only are agent identifiers not
revealed to clients, they are owned by the EZID administrator and can
only be viewed by the EZID administrator.  To avoid coding
complications (ezid.getMetadata is used both to service client
requests and by EZID itself) this special access control is
implemented in the API and UI, not in ezid.py.

The search database contains agent identifiers; see
.../etc/search-schema.sql for a potential privacy/security hole.

6. Case sensitivity of LDAP UIDs
--------------------------------

LDAP UIDs are case-insensitive.  Whenever EZID stores a UID (e.g., in
session cookies and in co-owner lists), it always uses the UID as
retrieved from LDAP.  In other words, when LDAP is enabled, EZID's
behavior regarding UIDs is case-insensitive and case-preserving.

#! /usr/bin/env python

# Performs a cleanup pass to insert into or update in the store
# database those identifiers that were touched in any way between the
# time the populate-store-1 script was started and the time the new
# database was installed in the running server.  Let 'date' be the
# last timestamp observed in the EZID transaction log before running
# populate-store-1.  After running populate-store-1, the general
# procedure for running this script is:
#
#    SR=.../SITE_ROOT
#    PR=$SR/PROJECT_ROOT
#
#    $PR/tools/filterlog -CSD -s $SR/logs/transaction_log |
#      awk '($1 " " $2) > "date"' | $PR/tools/populate-store-2
#
# This script requires several EZID modules.  The PYTHONPATH
# environment variable must include the .../SITE_ROOT/PROJECT_ROOT
# directory; if it doesn't, we attempt to dynamically locate it and
# add it.  The DJANGO_SETTINGS_MODULE environment variable must be
# set; if it isn't, we set it to "settings.production".
#
# Greg Janee <gjanee@ucop.edu>
# February 2013

import os
import sys

if "DJANGO_SETTINGS_MODULE" not in os.environ:
  os.environ["DJANGO_SETTINGS_MODULE"] = "settings.production"

try:
  import settings
except ImportError:
  sys.path.append(
    os.path.split(os.path.split(os.path.abspath(__file__))[0])[0])
  import settings

# Bootstrapping: reference a(ny) Django setting to trigger the loading
# of said settings, which causes the PYTHONPATH to be modified,
# supporting subsequent imports.
import django.conf
django.conf.settings.PROJECT_ROOT

# Configure the logging so that errors don't get added to the server's
# log file.
django.conf.settings.LOGGING_CONFIG_FILE = "logging.offline.conf"

import config
import noid
import store
import util

# We don't try to "replay" the transaction log, but rather, use it
# just to identify those identifiers touched in any way.  We then
# probe the server to get the current states of those identifiers.
# Unfortunately, we can't use ezid.py functions here because the store
# database operates at a lower level, so we have to use noid directly
# and mimic how ezid.py uses noid.

ids = set()

for l in sys.stdin:
  v = l.split(" ")
  if v[2] == "createArk":
    ids.add(util.decode(v[3]))
  elif v[2] == "createDoi":
    ids.add(util.doi2shadow(util.decode(v[3])))
  elif v[2] == "createUrnUuid":
    ids.add(util.urnUuid2shadow(util.decode(v[3])))
  elif v[2] == "setMetadata" or v[2] == "deleteIdentifier":
    id = util.decode(v[3])
    if id.startswith("ark:/"):
      ids.add(id[5:])
    elif id.startswith("doi:"):
      ids.add(util.doi2shadow(id[4:]))
    elif id.startswith("urn:uuid:"):
      ids.add(util.urnUuid2shadow(id[9:]))
    else:
      sys.stderr.write(("populate-store-2: unrecognized identifier " +\
        "scheme: %s\n") % id)

bindNoid = noid.Noid(config.config("DEFAULT.bind_noid"))

for id in ids:
  r = bindNoid.getElements(id)
  if r != None:
    store.update(id, r, insertIfNecessary=True)
  else:
    store.delete(id)

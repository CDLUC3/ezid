#! /usr/bin/env python

# Expunges expired test identifiers.  Identifiers are read from a noid
# database or from the EZID store database; expired identifiers are
# expunged by deleting them from the corresponding (live) EZID system.
# Usage:
#
#   expunge {dbpath|-}
#     dbpath: noid database pathname (.bdb)
#
# This script can also be used to dump a noid database.  The output is
# UTF-8 encoded.  Alternate usage:
#
#   expunge dbpath -p [azbocrtke]
#     print/debug mode; argument is one or more flags:
#     a: print all entries (a=z+b)
#     z: print all non-identifier entries
#     b: print all identifier bindings (b=o+c)
#     o: print bindings other than _c
#     c: print _c bindings (c=r+t)
#     r: print _c bindings of real (non-test) identifiers
#     t: print _c bindings of test identifiers (t=k+e)
#     k: print _c bindings of test identifiers to be kept
#     e: print _c bindings of expired test identifiers
#
# This script requires several EZID modules.  The PYTHONPATH
# environment variable must include the .../SITE_ROOT/PROJECT_ROOT
# directory; if it doesn't, we attempt to dynamically locate it and
# add it.  The DJANGO_SETTINGS_MODULE environment variable must be
# set.
#
# Greg Janee <gjanee@ucop.edu>
# April 2011

import bsddb.db
import os.path
import re
import sys
import time
import urllib
import urllib2

# The following must precede any EZID module imports:
execfile(os.path.join(os.path.split(os.path.abspath(__file__))[0],
  "offline.py"))

import config
import noid_egg
import store
import util

testArkPrefix = config.get("shoulders.ark_test")[5:]
testDoiPrefix = util.doi2shadow(config.get("shoulders.doi_test")[4:])
lifetime = 2*7*24*60*60 # seconds
baseUrl = config.get("DEFAULT.ezid_base_url")
adminPassword = config.get("auth.admin_password")

usageText = """Usage:

  expunge {dbpath|-}
    dbpath: noid database pathname (.bdb)

  expunge dbpath -p [azbocrtke]
    print/debug mode; argument is one or more flags:
    a: print all entries (a=z+b)
    z: print all non-identifier entries
    b: print all identifier bindings (b=o+c)
    o: print bindings other than _c
    c: print _c bindings (c=r+t)
    r: print _c bindings of real (non-test) identifiers
    t: print _c bindings of test identifiers (t=k+e)
    k: print _c bindings of test identifiers to be kept
    e: print _c bindings of expired test identifiers
"""

if len(sys.argv) == 2:
  dbPath = sys.argv[1] if sys.argv[1] != "-" else None
  debug = ""
elif len(sys.argv) == 4 and sys.argv[2] == "-p" and\
  re.match("[azbocrtke]+$", sys.argv[3]):
  dbPath = sys.argv[1]
  debug = sys.argv[3]
  for f, ff in [("a", "zb"), ("b", "oc"), ("c", "rt"), ("t", "ke")]:
    if f in debug: debug += ff
else:
  sys.stderr.write(usageText)
  sys.exit(1)

def output (flag, k, v):
  if flag in debug: print ("%s -> %s" % (k, v)).encode("UTF-8")

expungeList = []

if dbPath:
  db = bsddb.db.DB()
  db.open(dbPath, flags=bsddb.db.DB_RDONLY)
  cursor = db.cursor()
  entry = cursor.first()
  while entry != None:
    k, v = entry
    if "|" not in k:
      output("z", k, v)
    else:
      id, label = k.split("|", 1)
      id = noid_egg.decodeRaw(id)
      label = noid_egg.decodeRaw(label)
      v = v.decode("UTF-8")
      if not id.startswith("ark:/") or util.validateArk(id[5:]) != id[5:]:
        output("z", k, v)
      else:
        id = id[5:]
        if label != "_c" or not re.match("[0-9]+$", v):
          output("o", k, v)
        elif not id.startswith(testArkPrefix) and\
          not id.startswith(testDoiPrefix):
          output("r", k, v)
        else:
          creationTime = int(v)
          if int(time.time())-creationTime < lifetime:
            output("k", k, v)
          else:
            output("e", k, v)
            expungeList.append(id)
    entry = cursor.next()
  db.close()
else:
  for prefix in [testArkPrefix, testDoiPrefix]:
    # Let P be the lexicographically first possible test identifier
    # (i.e., the prefix itself).  Then our starting point is a
    # fictitious identifier that strictly precedes P, but is as close
    # to P as possible.
    lastId = prefix[:-1]
    while True:
      ids = store.harvest(start=lastId, maximum=1000)
      if len(ids) == 0 or\
        (ids[0][0] > prefix and not ids[0][0].startswith(prefix)):
        break
      for id, m in ids:
        if id.startswith(prefix) and int(time.time())-int(m["_c"]) >= lifetime:
          expungeList.append(id)
      lastId = ids[-1][0]

opener = urllib2.build_opener()
h = urllib2.HTTPBasicAuthHandler()
h.add_password("EZID", baseUrl, "admin", adminPassword)
opener.add_handler(h)

def deleteIdentifier (identifier):
  # Though we read identifiers directly (from a noid database or EZID
  # store database), to avoid conflicts with the corresponding running
  # system we don't delete identifiers directly, but ask the system to
  # do so.
  r = urllib2.Request("%s/id/%s" % (baseUrl, urllib.quote(identifier, ":/")))
  r.get_method = lambda: "DELETE"
  c = None
  try:
    c = opener.open(r)
    s = c.read()
    assert s.startswith("success:"), "unexpected response received: " + s
  except urllib2.HTTPError, e:
    if e.fp != None:
      try:
        m = e.fp.read()
      except Exception:
        pass
      else:
        if not e.msg.endswith("\n"): e.msg += "\n"
        e.msg += m
    raise e
  finally:
    if c: c.close()

if debug == "":
  for id in expungeList:
    try:
      deleteIdentifier("ark:/" + id)
    except Exception:
      sys.stderr.write("expunge: processing %s\n" % id)
      raise

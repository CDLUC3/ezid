#! /usr/bin/env python

# Compares target URLs stored in a raw dump file with target URLs
# stored in DataCite (and, by implied extension, the Handle System).
# This script loops through the dump file, and thus will detect
# identifiers missing in DataCite but not the converse.  Usage:
#
#    diff-datacite-1 infile
#
# The infile must be prepared from a raw dump file by selecting all
# non-test DOIs whose status is not reserved, and projecting qualified
# identifier names and target URLs, i.e., by using the command:
#
#    select _id =~ '/b/' and not _id =~ '/b5072\/fk2/' and
#       not _is = reserved | project -d _s _st
#
# This script requires an EZID module.  The PYTHONPATH environment
# variable must include the .../SITE_ROOT/PROJECT_ROOT directory; if
# it doesn't, we attempt to dynamically locate it and add it.  The
# DJANGO_SETTINGS_MODULE environment variable must be set; if it
# isn't, we set it to "settings.production".
#
# Greg Janee <gjanee@ucop.edu>
# April 2013

import os
import sys

if "DJANGO_SETTINGS_MODULE" not in os.environ:
  os.environ["DJANGO_SETTINGS_MODULE"] = "settings.production"

try:
  import settings
except ImportError:
  sys.path.append(os.path.split(os.path.split(
    os.path.abspath(__file__))[0])[0])
  import settings

# Bootstrapping: reference a(ny) Django setting to trigger the loading
# of said settings, which causes the PYTHONPATH to be modified,
# supporting subsequent imports.
import django.conf
django.conf.settings.PROJECT_ROOT

# Configure the logging so that errors don't get added to the server's
# log file.
django.conf.settings.LOGGING_CONFIG_FILE = "logging.offline.conf"

import datacite

if len(sys.argv) != 2:
  sys.stderr.write("Usage: diff-datacite-1 infile\n")
  sys.exit(1)

for l in open(sys.argv[1]):
  id, url = l[:-1].split(" ", 1)
  assert id.startswith("doi:")
  r = datacite.getTargetUrl(id[4:])
  if r == None:
    print "missing:", id
  elif r != url:
    print "discrepancy:", id
    print "\tlocal:   ", url
    print "\tDataCite:", r

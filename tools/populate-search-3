#! /usr/bin/env python

# Performs the last of three steps in populating the search database
# from a raw dump file.  This script performs a cleanup pass to insert
# into or update in the search database those identifiers that were
# touched in any way between the time the dump was created and now.
# Let EPOCH be the last timestamp observed in the EZID transaction log
# before starting to create the database dump.  Usage:
#
#    SR=.../SITE_ROOT
#    PR=$SR/PROJECT_ROOT
#
#    $PR/tools/filterlog -CSD -s $SR/logs/transaction_log |
#      awk '($1 " " $2) > "EPOCH"' | $PR/tools/populate-search-3
#
# (Depending on the time it takes this script to run, it may be
# necessary to repeat the above process for increasing epochs.)
#
# This script requires several EZID modules.  The PYTHONPATH
# environment variable must include the .../SITE_ROOT/PROJECT_ROOT
# directory; if it doesn't, we attempt to dynamically locate it and
# add it.  The DJANGO_SETTINGS_MODULE environment variable must be
# set.
#
# Greg Janee <gjanee@ucop.edu>
# November 2015

import os.path
import sys

# The following must precede any EZID module imports:
execfile(os.path.join(os.path.split(os.path.abspath(__file__))[0],
  "offline.py"))

import ezidapp.models
import ezidapp.models.search_identifier
import store
import util

# We don't try to "replay" the transaction log, but rather, use it
# just to identify those identifiers touched in any way.  We then
# probe EZID directly to get the current states of those identifiers.

ids = set()

for l in sys.stdin:
  v = l.split(" ")
  if v[2] in ["mintArk", "mintDoi"]:
    pass
  elif v[2] == "createArk":
    id = util.decode(v[3])
    ids.add(("ark:/" + id, id))
  elif v[2] == "createDoi":
    id = util.decode(v[3])
    ids.add(("doi:" + id, util.doi2shadow(id)))
  elif v[2] == "createUrnUuid":
    id = util.decode(v[3])
    ids.add(("urn:uuid:" + id, util.urnUuid2shadow(id)))
  elif v[2] in ["setMetadata", "deleteIdentifier"]:
    id = util.decode(v[3])
    if id.startswith("ark:/"):
      ids.add((id, id[5:]))
    elif id.startswith("doi:"):
      ids.add((id, util.doi2shadow(id[4:])))
    elif id.startswith("urn:uuid:"):
      ids.add((id, util.urnUuid2shadow(id[9:])))
    else:
      assert False, "unrecognized identifier type"
  else:
    sys.stderr.write("warning: input line ignored: %s\n" % l.strip())

for id, shadowArk in ids:
  r = store.get(shadowArk)
  if r != None:
    metadata, updateTime, oaiVisible = r
    # Ah, shadow ARKs, how I hate thee.  Although we have computed
    # actual identifiers above, an operation directly on a shadow ARK
    # will look like an operation on an ARK, so we have to go to extra
    # work to ensure we have the real identifier.
    if "_s" in metadata: id = metadata["_s"]
    if metadata["_o"] != "anonymous":
      ezidapp.models.search_identifier.updateFromLegacy(id, metadata)
  else:
    # Per the comment above, if an identifier is deleted by its shadow
    # ARK, we have no means of looking up the real identifier, and so
    # will fail to delete it.
    ezidapp.models.SearchIdentifier.objects.filter(identifier=id).delete()

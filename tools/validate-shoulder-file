#! /usr/bin/env python

# Validates a shoulder file.  Usage:
#
#    validate-shoulder-file [-p password] file shoulders...
#
# Any shoulders defined in the file that are also listed on the
# command line are operationally tested.  Note that testing DOI
# shoulders requires the password of the DataCite allocator account,
# which can be supplied with the -p option.
#
# See shoulder_parser.py for the format of a shoulder file.
#
# This script requires several standalone EZID modules (noid,
# shoulder_parser, and util).  If they're not found in the current
# directory or in the default PYTHONPATH, we attempt to load them from
# the lib and then the ../code directories relative to the directory
# containing this script.  This script also requires the mdsadmin
# script; it is expected to be in the directory containing this
# script.
#
# Greg Janee <gjanee@ucop.edu>
# October 2013

import optparse
import os.path
import re
import subprocess
import sys

thisDir = os.path.split(os.path.abspath(__file__))[0]

try:
  import shoulder_parser
except ImportError:
  try:
    sys.path.append(os.path.join(thisDir, "lib"))
    import shoulder_parser
  except ImportError:
    sys.path.append(os.path.join(os.path.split(thisDir)[0], "code"))
    import shoulder_parser

import noid
import util

exitStatus = 0

def error (message):
  global exitStatus
  sys.stderr.write("validate-shoulder-file: %s\n" % message)
  exitStatus = 1

def fatal (message):
  error(message)
  sys.exit(1)

p = optparse.OptionParser(usage="%prog [-p password] file shoulders...")
p.add_option("-p", action="store", dest="password", default=None,
  help="DataCite allocator password")
options, args = p.parse_args()
if len(args) < 1:
  p.print_help()
  sys.exit(1)
infile = args[0]
shouldersToTest = args[1:]

try:
  fileContent = open(infile).read()
except Exception, e:
  fatal(str(e))

entries, errors, warnings = shoulder_parser.parse(fileContent)

if len(errors) > 0 or len(warnings) > 0:
  l = [("ERROR", e[0], e[1]) for e in errors] +\
    [("WARNING", w[0], w[1]) for w in warnings]
  l.sort(key=lambda ew: ew[1])
  for ew in l: error("%s line %d: %s" % ew)

if len(errors) > 0: fatal("validation failed")
exitStatus = 0

def testMinter (shoulder, minter):
  try:
    id = noid.Noid(minter).mintIdentifier()
  except Exception, e:
    error("shoulder '%s': minter failure: %s" % (shoulder, str(e)))
    return
  if shoulder.startswith("ark:/"):
    id = "ark:/" + id
  elif shoulder.startswith("doi:"):
    id = "doi:" + util.shadow2doi(id)
  if not id.startswith(shoulder):
    error("shoulder '%s': minter does not match shoulder" % shoulder)

def testDatacenter (shoulder, datacenter):
  pipe = subprocess.Popen([os.path.join(thisDir, "mdsadmin"), options.password,
    "view", datacenter], stdout=subprocess.PIPE)
  output, unused = pipe.communicate()
  if pipe.wait() != 0:
    error("shoulder '%s': mdsadmin command failed" % shoulder)
    return
  prefix = re.match("doi:(10\.\d+)/", shoulder).group(1)
  prefixes = re.search("^prefixes: (.*)$", output,
    re.MULTILINE).group(1).split(", ")
  if prefix not in prefixes:
    error("shoulder '%s': prefix is not supported by datacenter" % shoulder)

for shoulder in shouldersToTest:
  sl = [e for e in entries if e.type == "shoulder" and e.key == shoulder]
  if len(sl) == 0:
    error("no such shoulder: %s" % shoulder)
    continue
  entry = sl[0]
  if entry.minter != "": testMinter(shoulder, entry.minter)
  if shoulder.startswith("doi:"):
    if options.password:
      testDatacenter(shoulder, entry.datacenter)
    else:
      error("testing DOI shoulders requires password")

sys.exit(exitStatus)

#! /usr/bin/env python

# Performs an initial population of the search database from a noid
# bind database.  The general procedure for building and installing
# the search database is:
#
#    SR=.../SITE_ROOT
#    PR=$SR/PROJECT_ROOT
#
#    sqlite3 NEWDB < $PR/etc/search-schema.sql
#    $PR/tools/dump -n .../noid.bdb |
#      $PR/tools/select not _owner = anonymous | gzip > DUMP
#    $PR/tools/populate-search-1 DUMP NEWDB
#    sqlite3 NEWDB analyze
#    (stop server)
#    mv NEWDB $SR/db/search.sqlite3
#    (start server)
#    (deal with any fixups using populate-search-2)
#
# The search database can also be populated from a raw dump using the
# slightly different commands:
#
#    $PR/tools/dump -r .../noid.bdb |
#      $PR/tools/select not _o = anonymous | gzip > DUMP
#
# This script requires several EZID modules.  The PYTHONPATH
# environment variable must include the .../SITE_ROOT/PROJECT_ROOT
# directory; if it doesn't, we attempt to dynamically locate it and
# add it.  The DJANGO_SETTINGS_MODULE environment variable must be
# set.
#
# Greg Janee <gjanee@ucop.edu>
# February 2012

import gzip
import os.path
import re
import sys

# The following must precede any EZID module imports:
execfile(os.path.join(os.path.split(os.path.abspath(__file__))[0],
  "offline.py"))

import search
import util

if len(sys.argv) != 3:
  sys.stderr.write("usage: populate-search-1 dumpfile databasefile\n")
  sys.exit(1)

search.setDatabase(sys.argv[2])

for l in gzip.GzipFile(filename=sys.argv[1], mode="r"):
  lv = l[:-1].split(" ")
  record = { "_id": lv[0] }
  for i in range(1, len(lv), 2):
    v = util.decode(lv[i+1]).strip()
    if v != "": record[util.decode(lv[i])] = v
  if not re.match("[a-z]+:", record["_id"]):
    # Looks like we're reading from a raw dump.
    if "_s" in record:
      record["_id"] = util.decode(record["_s"])
    else:
      record["_id"] = "ark:/" + record["_id"]
  search.insert(record["_id"], record)

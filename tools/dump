#! /usr/bin/env python

# The 'dump', 'select', and 'project' scripts form a bind database
# query system.  The general usage is:
#
#    dump noid.bdb | select constraint... | project fields...
#
# This script dumps a noid bind database to standard output.  One line
# is written per identifier using the space-separated format
#
#    identifier label value label value ...
#
# where the identifier is qualified and field labels and values are
# left in their encoded forms (i.e., as stored by EZID) except that
# internal field labels are converted to their transmitted forms and
# agent (i.e., user and group) identifiers are converted to local
# names. For example:
#
#    ark:/99166/p92z12p14 _owner admin _created 1284137828 ...
#
# Note: the identifier itself is not encoded.  Also, note that empty
# values are, well, empty, and hence will result in adjacent spaces.
#
# Note: identifiers are NOT written in lexicographic order.
#
# If the -n option is specified, agent identifier conversion is NOT
# performed.
#
# If the -s option is specified, shadow ARKs are included in the
# output (in addition to and separate from the shadowed identifiers).
# As noted above, internal field labels are converted to their
# transmitted forms.  Thus a shadow ARK's _t field is output as the
# shadow ARK's _target field and its _st field is output as the
# shadowed identifier's _target field.  If the -s option is not
# specified, shadow ARKs are not output at all.
#
# If the -r ("raw") option is specified, identifiers are output as
# stored in noid (i.e., as unqualified ARKs); internal field labels
# are NOT converted; and all internal fields (_t and _st, _t1, etc.)
# are output.  Thus, the raw output exactly echoes what is stored in
# noid.  The -r option implies the -n option; options -r and -s are
# incompatible.
#
# If the -z option is specified, the output is gzip-compressed.
#
# This script requires several EZID modules.  The PYTHONPATH
# environment variable must include the .../SITE_ROOT/PROJECT_ROOT
# directory; if it doesn't, we attempt to dynamically locate it and
# add it.  The DJANGO_SETTINGS_MODULE environment variable must be
# set.
#
# Interim modification: we account for the fact that identifiers are
# prefixed with "ark:/" when stored in noid.
#
# Greg Janee <gjanee@ucop.edu>
# December 2011

import bsddb.db
import gzip
import optparse
import os.path
import sys

# The following must precede any EZID module imports:
execfile(os.path.join(os.path.split(os.path.abspath(__file__))[0],
  "offline.py"))

import ezidapp.models
import noid_egg
import util

labelMapping = {
  "_o": "_owner",
  "_g": "_ownergroup",
  "_co": "_coowners",
  "_c": "_created",
  "_u": "_updated",
  "_t": "_target",
  "_s": "_shadows",
  "_p": "_profile",
  "_is": "_status",
  "_x": "_export",
  "_d": "_datacenter",
  "_cr": "_crossref"
}

p = optparse.OptionParser(usage="%prog [-nrsz] noid.bdb")
p.add_option("-n", action="store_false",
  dest="convertAgents", default=True, help="do NOT convert agent identifiers")
p.add_option("-r", action="store_true", dest="rawOutput",
  help="raw dump")
p.add_option("-s", action="store_true",
  dest="includeShadowArks", default=False, help="include shadow ARKs")
p.add_option("-z", action="store_true",
  dest="gzipOutput", default=False, help="gzip output")
options, args = p.parse_args()
if len(args) != 1: p.error("wrong number of arguments")
if options.rawOutput:
  if options.includeShadowArks: p.error("options -r and -s are incompatible")
  options.convertAgents = False
dbfile = args[0]

if options.gzipOutput:
  outfile = gzip.GzipFile(fileobj=sys.stdout, mode="w")
else:
  outfile = sys.stdout

def warning (id, message):
  sys.stderr.write("dump: warning: %s: %s\n" % (id, message))

def outputRecord1 (id, record):
  outfile.write(id)
  for k in record:
    if options.rawOutput:
      outfile.write(" %s %s" % (util.encode4(k), util.encode3(record[k])))
    else:
      outfile.write(" %s %s" % (util.encode4(labelMapping.get(k, k)),
        util.encode3(record[k])))
  outfile.write("\n")

def outputRecord (id, record):
  if options.rawOutput:
    outputRecord1(id, record)
  else:
    if record.get("_is", "public") != "public":
      if "_t1" in record:
        record["_t"] = record["_t1"]
      else:
        warning(id, "missing _t1")
      if "_st1" in record: record["_st"] = record["_st1"]
    if "_t1" in record: del record["_t1"]
    if "_st1" in record: del record["_st1"]
    if "_s" in record:
      if "_su" in record:
        su = record["_su"]
        del record["_su"]
      else:
        warning(id, "missing _su")
        su = None
      if "_st" in record:
        st = record["_st"]
        del record["_st"]
      else:
        warning(id, "missing _st")
        st = None
      if options.includeShadowArks: outputRecord1("ark:/" + id, record)
      if su != None: record["_u"] = su
      if st != None: record["_t"] = st
      s = record["_s"]
      del record["_s"]
      record["_shadowedby"] = "ark:/" + id
      outputRecord1(s, record)
    else:
      outputRecord1("ark:/" + id, record)

db = bsddb.db.DB()
db.open(dbfile, flags=bsddb.db.DB_RDONLY)
cursor = db.cursor()
entry = cursor.first()
lastId = None
while entry != None:
  k, value = entry
  if "|" in k:
    id, label = k.split("|", 1)
    id = noid_egg.decodeRaw(id)
    label = noid_egg.decodeRaw(label)
    value = value.decode("UTF-8")
    if id.startswith("ark:/") and util.validateArk(id[5:]) == id[5:] and\
      not label.startswith("__") and not label.startswith("_.e"):
      id = id[5:]
      # The fundamental assumption of this loop is that bindings
      # (binding = identifier + "|" + label) are stored in
      # lexicographic order.  But that doesn't imply that identifiers
      # themselves are returned in lexicographic order.
      if id != lastId:
        if lastId is not None: outputRecord(lastId, record)
        record = {}
      if options.convertAgents:
        if label == "_o":
          record["_o"] = ezidapp.models.getUserByPid(value).username
        elif label == "_g":
          record["_g"] = ezidapp.models.getGroupByPid(value).groupname
        elif label == "_co":
          record["_co"] = " ; ".join(
            ezidapp.models.getUserByPid(co.strip()).username\
            for co in value.split(";") if len(co.strip()) > 0)
        else:
          record[label] = value
      else:
        record[label] = value
      lastId = id
  entry = cursor.next()
if lastId is not None: outputRecord(lastId, record)
db.close()

outfile.close()
